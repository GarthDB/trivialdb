{"name":"JBase","tagline":"A lightweight key/value json storage with persistence and a simple model api.","body":"# JBase\r\n\r\n[![Build Status](https://travis-ci.org/Morgul/jbase.svg?branch=master)](https://travis-ci.org/Morgul/jbase)\r\n\r\nA lightweight key/value json storage with persistence. Conceptually, it's just a thin API wrapper around plain javascript\r\nobjects; with the added bonus of doing throttled asynchronous writes on changes. Its on disk format is simply \"json on\r\ndisk\"; basically the jsonified version of the plain object, saved to a file on disk. This makes making hand edits not\r\njust possible, but simple.\r\n\r\n## Use Case\r\n\r\nJBase is intended for simple storage needs. It's in-process, small, and very fast for small data sets. It takes almost\r\nnothing to get up and going with it, and it has just enough features to make it worth while. Personally I've found its\r\na great fit for a development database for websites, or even to power a simple blog.\r\n\r\nThe one caveat to keep in mind is this: _every database your work with is stored in memory_. Since JBase is in-process,\r\nyou might run into the memory limit of node; on versions before 0.11+ there's a 1.4GB limit. If you try and load a\r\ndatabase of all your cat pictures, you might run out of memory pretty quickly.\r\n\r\nThat being said, this isn't actually much of a limitation. Generally, you're working with a large amount of your data\r\nin memory anyway; your data sets can get relatively large before you even need to worry about this.\r\n\r\n## Installation\r\n\r\nSimply install with npm:\r\n\r\n```bash\r\n$ npm install --save jbase\r\n```\r\n\r\n## API\r\n\r\nThe JBase API is inspired (spiritually) by [RethinkDB](http://rethinkdb.com/) and it's node.js ORM,\r\n[thinky](http://thinky.io/). These are two great projects, and once you outgrow JBase, I strongly encourage you to\r\ncheck them out!\r\n\r\nThere are two different APIs, the low-level 'Database' API, and the higher level 'Model' API. Previous versions of JBase\r\nonly had the Database API, so if you want to use what you're used to, feel free to keep using it. (You can even use both\r\ntogether in various ways.)\r\n\r\n### Model API\r\n\r\nThe model API was added to make JBase feel much more like the larger ORM style solutions out there. I'm a very big fan\r\nof working with models as opposed to direct database calls, and I've taken some of my favorite features and baked them\r\ndirectly into JBase. Here's the current feature list:\r\n\r\n* Model validation\r\n* Simple model definitions\r\n* Models serialize as JSON objects\r\n* Get & Filter functions that return model instances\r\n* Automatic syncing of database changes to Model instances\r\n* Manual syncing of Model instances with the database\r\n\r\nDon't worry, you are not required to use the Model API, or even know it's there.\r\n\r\n#### Defining a model\r\n\r\n* `defineModel(databaseName, modelDefinition, databaseOptions)` - Returns a `JDBModel`.\r\n\r\nDefining a model in JBase is very simple. Models and databases have a one to one relationship, so you can think of the\r\n`databaseName` as the name of the model, though they don't have to have an relation to each other.\r\n\r\n_Note_: You will need to save the return value of `defineModel` and use that for querying or creating new instances.\r\n\r\n```javascript\r\n\r\n// Define a user model\r\nvar User = jbase.defineModel('users', {\r\n    name: { type: String, required: true },\r\n    age: Number,\r\n    admin: { type: Boolean, required: true, default: false }\r\n});\r\n\r\n// Define an in-memory only model\r\nvar Session = jbase.defineModel('sessions', {\r\n    userID: { type: String, required: true }\r\n}, { writeToDisk: false });\r\n```\r\n\r\n##### Type Definition Object\r\n\r\nThe model definition is a simple object where the value is either a javascript type (String, Boolean, Number, etc.), or\r\na type definition object. The supported options are:\r\n\r\n* `type` - Required. This must be a javascript type (String, Boolean, Number, etc).\r\n* `required` - Optional. If false (the default), null and undefined are allowed values for this field.\r\n* `default` - Optional. A value to default the field to. (This can easily be overwritten simply by assigning to the\r\nfield.)\r\n\r\n#### Creating a Model\r\n\r\nTo create a model, you simply create a new instance of the return value of `defineModel`, optionally passing in an\r\noption to populate the model with.\r\n\r\n```javascript\r\n// Create a regular user\r\nvar user = new User({ name: \"Some Person\", age: 23 });\r\n```\r\n\r\n#### Updating a model\r\n\r\nUpdating a model is as simple as modifying the model instance, and then calling save.\r\n\r\n```javascript\r\n// Create a regular user\r\nvar user = new User({ name: \"Some Person\", age: 23 });\r\n\r\n// Make the user an admin\r\nuser.admin = true;\r\n\r\n// Save the user\r\nuser.save();\r\n```\r\n\r\n#### Validating a Model\r\n\r\n* `model.validate()` - Returns a promise that either resolves, or rejects with a `ValidationError`.\r\n\r\nAll model instances have a `validate` function, which you can use to check to make sure the model is valid. When there\r\nis a validation error, you will get a `ValidationError` object with a `key` property that indicates the key that failed\r\nvalidation. You can catch this error using `.catch`\r\n\r\nCurrently, we only validate based on type, or the type definition object's options.\r\n\r\n```javascript\r\n// Create a regular user\r\nvar user = new User({ name: \"Some Person\", age: 23 });\r\n\r\n// Make the user an admin\r\nuser.admin = true;\r\n\r\n// This will resolve correctly.\r\nuser.validate().then(function()\r\n{\r\n    // We get here.\r\n});\r\n\r\n// Set the admin field to an invalid type\r\nuser.admin = 'not valid';\r\n\r\n// This will throw an error.\r\nuser.validate()\r\n    .then(function()\r\n    {\r\n        // We don't get here.\r\n    })\r\n    .catch(jbase.errors.ValidationError, function()\r\n    {\r\n        // We catch the error, and handle it here.\r\n    });\r\n```\r\n\r\n#### Saving a Model\r\n\r\n* `model.save(skipValidation)` - Returns a promise that either resolves, or rejects with an error.\r\n\r\nSaving a model is as simple as calling `save`. It first calls `validate`, which means that it may throw a\r\n`ValidationError`.\r\n\r\n```javascript\r\n// Create a regular user\r\nvar user = new User({ name: \"Some Person\", age: 23 });\r\n\r\n// Make the user an admin\r\nuser.admin = true;\r\n\r\n// Save the user\r\nuser.save()\r\n    .then(function()\r\n    {\r\n        // Saved!\r\n    });\r\n```\r\n\r\n#### Syncing\r\n\r\nNormally, in an ORM, if you either create a new model instance, or get a model instance somehow, and something else\r\nchanges the database, your model instance is out of date and doesn't get those changes. However, because of the nature\r\nof JBase, it was very easy to make the models smart enough to update themselves whenever something changes in the\r\ndatabase.\r\n\r\nThat being said, there is an issue of how do we merge your unsaved changes when something else has updated the database?\r\nThe design we've chosen is that whenever you model is dirty (`model.$dirty` is true), we ignore the `sync` event. You\r\ncan still manually sync the object.\r\n\r\n##### Manual Syncing\r\n\r\n* `model.sync(force)` - returns a promise that resolves once the sync has completed.\r\n\r\nIf you want to sync your model instance (because you manually updated the database, for example), you can simply call\r\n`sync`. However, if your model is dirty, you will need to force the sync by passing `true` to the `sync` function.\r\n\r\n```javascript\r\n// Create a regular user\r\nvar user = new User({ name: \"Some Person\", age: 23 });\r\n\r\n// Make the user an admin\r\nuser.admin = true;\r\n\r\n// Force a sync\r\nuser.sync(true)\r\n    .then(function()\r\n    {\r\n        // user.admin is false here.\r\n    });\r\n```\r\n\r\nKeep in mind, when you force a sync, _all changes to the model instance will be lost_.\r\n\r\n#### Getting a Model by ID\r\n\r\n* `Model.get(modelID)` = returns a promise that either resolves with a model instance, ore rejects with a\r\n`DocumentNotFound` error.\r\n\r\nYou can easily get model instances by id. Simply call `Model.get` and pass in the id you're looking for. If the id does\r\nnot exist, the promise will be rejected with a `DocumentNotFound` error. You can easily test for this, and handle it\r\nusing `.catch`.\r\n\r\n```javascript\r\n// Get an existing id\r\nUser.get('existing-id')\r\n    .then(function(user)\r\n    {\r\n        // Work with user here\r\n    });\r\n\r\n// Get a non-existent id\r\nUser.get('existing-id')\r\n    .catch(jbase.errors.DocumentNotFound, function(error)\r\n    {\r\n        // Handle not found case\r\n    });\r\n```\r\n\r\n#### Filtering models\r\n\r\n* `Model.filter(filter)` - returns a promise that resolves to a list, or an error.\r\n\r\nInstead, if you want to get a list of possible values, you should use `filter`. Just like the Database API function of\r\nthe same name, we support filter functions, `_.pluck` and `_.where` style filters. The results are _always_ as list, so\r\nif nothing matched your filter, you will get back an empty list.\r\n\r\n```javascript\r\n// Get a list of admins\r\nUser.filter({ admin: true })\r\n    .then(function(admins)\r\n    {\r\n        // Work with the list of admins.\r\n    });\r\n```\r\n\r\n#### Working with the database\r\n\r\nYou can work with the database object for a particular model by using the `$$db` object. While I don't recommend doing\r\nthings this way, should you need it, you can use it.\r\n\r\n### Database API\r\n\r\nThis is the API that previous versions of JBase pioneered. It's relatively low-level, and if that's how you'd rather\r\nwork with your database, that's fine. It is still the primary focus of JBase.\r\n\r\n#### **New in 1.0.0**\r\n\r\nThe Database API has recently changed. As I've been building projects, I've discovered that Promise-based APIs are both elegant\r\nand incredibly convenient. I have opted to make the almost entire API promise-based. This has a small performance hit on\r\nindividual operations, however, it also makes all calls asynchronous, which helps with JBase's ability to handle load.\r\n\r\nIf you do not like promises, or disagree with this change, then I recommend using\r\n[v0.9.0](https://github.com/Morgul/jbase/releases/tag/v0.9.0).\r\n\r\n##### Promises\r\n\r\nBecause of the change to promises, JBase now exposes our internal Promise object as `jbase.Promise`, so you can\r\nleverage it  if you want to. (We use [bluebird](https://github.com/petkaantonov/bluebird).)\r\n\r\n```javascript\r\nvar jbase = require('jbase');\r\nvar Promise = jbase.Promise;\r\n\r\n// Work with `Promise` here\r\n```\r\n\r\n#### Loading or saving databases\r\n\r\n* `db(databaseName, options)` - Returns a database instance.\r\n\r\nJBase lazily loads databases. JBase also creates databases if they don't exist. To load or create a database:\r\n\r\n```javascript\r\n// Open or create a database\r\nvar db = jbase.db('some_db');\r\n\r\n// Open or create a database, with options\r\nvar db = jbase.db('some_db', { writeToDisk: false });\r\n```\r\n\r\nThis will look for a file named `\"./some_db.json\"`. (If your database lives somewhere else, you can pass the `rootPath`\r\noption in to the `db` call.)\r\n\r\n##### New in 1.0.0\r\n\r\nYou can now request the same database multiple times, and get back the same instance. This allows you to request the\r\ndatabase by name in different places in your code, and not worry about the two database instance fighting with each\r\nother. (The previous behavior was clearly broken, and resulted in very strange issues.)\r\n\r\n_Note_: When you request a database any other time than the first, the options are ignored. There is currently no way to\r\nchange a database's options at run time.\r\n\r\n##### Options\r\n\r\nThe options supported by the `db` call are:\r\n\r\n```javascript\r\n{\r\n    writeToDisk: true | false,  // Whether or not to persist the database to disk. (Default: `true`)\r\n    loadFromDisk: true | false, // Whether or not to read the database in from disk on load. (Default: `true`)\r\n    rootPath: \"...\",            // The path to a folder that will contain the persisted database json files. (Default: './')\r\n    writeDelay: ...,            // A number in milliseconds to wait between writes to the disk. (Default: 0)\r\n    prettyPrint: true | false   // Whether or not the json on disk should be pretty printed. (Default: `true`)\r\n}\r\n```\r\n\r\n#### Storing Values\r\n\r\n* `store(value)` - Returns a promise resolved with `key`.\r\n* `store(key, value)` - Returns a promise resolved with `key`.\r\n\r\nSince JBase is a key/value storage, all values are stored under a key. This key is not part of the value that gets stored,\r\nsince JBase never modifies your value. Also, while you can specify a key, you will need to ensure it's unique (otherwise\r\nit will silently overwrite). Instead, I recommend you let JBase create the key for you (by not passing one).\r\n\r\nWhen you let JBase auto generate the key, you can find out what that key was by using `.then()`, which will be passed\r\nthe newly generated key.\r\n\r\n```javascript\r\n// Store an object\r\ndb.store({ foo: \"bar!\", test: \"Apples\" })\r\n    .then(function(key)\r\n    {\r\n        // Work with `key` here\r\n    };\r\n\r\nvar key = undefined\r\n// We support auto generating keys whenever the key parameter is undefined.\r\ndb.store(key, { foo: \"bar!\", test: \"Apples\" })\r\n    .then(function(key)\r\n    {\r\n        // Work with `key` here\r\n    };\r\n\r\n// Store an object with key\r\ndb.store('my_key', { foo: \"bar!\", test: \"Apples\" })\r\n    .then(function(key)\r\n    {\r\n        // `key` == 'my_key'\r\n    };\r\n```\r\n\r\n#### Retrieving Values\r\n\r\n* `get(key)` - Returns a promise resolved to the value or `undefined`.\r\n\r\nJBase only supports direct lookups by key. It returns a promise resolved to the value stored.\r\n\r\n```javascript\r\n// Get an object\r\ndb.get('my_key')\r\n    .then(function(val)\r\n    {\r\n        // Work with `val` here\r\n    });\r\n```\r\n\r\n#### Updating Values\r\n\r\n* `merge(key, partialObj)` - Returns a promise resolved to the new value.\r\n\r\nJBase support partial object updates. JBase will take whatever object you pass in, and merge that object with the value\r\nstored at that key. If there is no value, it works exactly like `store`. The resulting object is returned.\r\n\r\n```javascript\r\n// Update an object\r\ndb.merge('my_key', { test: \"Oranges\" })\r\n    .then(function(obj)\r\n    {\r\n        // Work with `obj` here\r\n    });\r\n\r\n```\r\n\r\n#### Filter Queries\r\n\r\n* `filter(filter)` - Returns a promise resolved to an object of filtered values.\r\n\r\nSometimes, you need to query based on more than just the key. To do that, JBase gives you a very simple filter query. It\r\niterates over every value in the database, and passes that into your filter function. If the function returns true, that\r\nvalue is included in the results, otherwise it's omitted.\r\n\r\n```javascript\r\n// Filter Function\r\ndb.filter(function(value, key)\r\n{\r\n    // Decide if you want this object\r\n    return value.foo === 'bar!';\r\n}).then(function(results)\r\n{\r\n    // Work with `results` here.\r\n});\r\n```\r\n\r\n##### New in 1.0.0\r\n\r\nYou can now also pass in filter objects. We switched to using lodash under the hood, so we support their `_.pluck` &\r\n`_.where` style callbacks as well!\r\n\r\n```javascript\r\n// Filter object\r\ndb.filter({ foo: 'bar!' })\r\n    .then(function(results)\r\n    {\r\n        // Work with `results` here.\r\n    });\r\n```\r\n\r\n#### Direct Access\r\n\r\n* `sync()` - Returns a promise resolved once the database is considered 'settled'.\r\n\r\nYou can directly access the key/value store with the `values` property on the database instance. This is exposed\r\nexplicitly to allow you as much freedom to work with your data as you might want. However, JBase can't detect any\r\nchanges you make directly, so you will need to call the `sync` function to get your changes to persist to disk.\r\n\r\n```javascript\r\n// Add a new key manually\r\ndb.values['foobar'] = { test: \"something\" };\r\n\r\n// Sync that new key to disk\r\ndb.sync();\r\n```\r\n\r\nThe `sync` function returns a promise that is resolved once the database has 'settled', as in, there are not more\r\nscheduled writes. Because of this behavior, you should consider whether or not you want to wait on it's promise. Under\r\nhigh load, (or with a high `writeDelay`) it's possible for a `sync` promise's resolution to be considerably delayed.\r\n\r\n```javascript\r\n// Add a new key manually\r\ndb.values['foobar'] = { test: \"something\" };\r\n\r\n// Sync that new key to disk\r\ndb.sync()\r\n    .then(function()\r\n    {\r\n        // Sync is done, db is settled\r\n    });\r\n```\r\n\r\nAlso, you should feel free to iterate over the values object if you need to do any advanced filtering. All the same\r\ncaveats of working with a plain javascript object apply. Just remember to call `sync` if you've made any modifications.\r\n\r\n##### New in 1.0.0\r\n\r\nWhenever `store` or `merge` are called, a `sync` event is fired from the database object. You can use this should you\r\nneed to know when JBase is syncing to disk.\r\n\r\n## Status\r\n\r\nJBase is reasonably stable, and since the code base is small enough, it's relatively immune to the most common forms of\r\n'code rot'. I make improvements when they're needed, or if someone files an issue. That being said, I consider JBase\r\n'production ready', provided you meet the intended use case.\r\n\r\n## Contributing\r\n\r\nWhile I only work on JBase in my spare time (what little there is), I use it for several of my projects. I'm more than\r\nhappy to accept merge requests, and/or any issues filed. If you want to fork it and improve part of the API, I'm ok with\r\nthat too, however I ask you open an issue to discuss your proposed changes _first_. And, since it's MIT licensed, you\r\ncan, of course, take the code and use it in your own projects.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}